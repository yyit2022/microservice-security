= 微服务安全第二课(保护微服务的第一步)
:author: yyit
:stem: latexmath
:icons: font
:source-highlighter: coderay
:sectlinks:
:sectnumlevels: 4
:toc: left
:toc-title: 目录
:toclevels: 3

== 1. 构建你的第一个微服务

我们以一个零售商店应用程序为例，我们使用一组微服务来构建它。我们将使用 Spring Boot (https://spring.io/projects/spring-boot) 构建我们的第一个微服务，它接受创建和管理订单的请求。

Spring Boot 是一个基于 Spring 平台的框架，它允许您通过使用一组特殊的注解修饰您的代码，将用 Java 编程语言编写的函数转换为网络可访问的函数，称为服务或 API。
代码示例都可以在 GitHub (https://github.com/yyit2022/microservice-security) 上找到。

图 1 显示了一组微服务，它们是我们正在构建的零售商店应用程序的一部分，以及一组消费者应用程序。事实上，消费者应用程序是我们构建的微服务的消费者。

.1 在这个典型的微服务部署中，消费者应用程序（Web 应用程序或移动应用程序）代表其最终用户访问微服务，而微服务之间相互通信。
[caption="图 . "]
image::doc/2.1.dio.png[]

=== 1.1. 克隆示例库

 (1) 克隆示例 Git 源码库,运行以下命令:


 git clone  https://github.com/yyit2022/microservice-security.git

=== 1.2. 编译订单处理微服务

完成克隆步骤后，就该动手运行您的第一个微服务了。首先，在您的操作系统中打开命令行工具，然后导航到文件系统上克隆示例源码库的位置：

----
cd [microservice-security]/chapter02/sample01
----

在 `chapter02/sample01` 目录中，您将找到与订单处理微服务对应的源代码。在该目录中，执行以下命令以构建订单处理微服务：

----
mvn clean install
----

前面的命令指示 Maven 编译您的源代码并生成一个可运行的 artifact，称为 Java 存档 (JAR) 文件。请注意，您需要安装 Java 和 Maven 才能成功执行此步骤。如果您的构建成功，您将看到消息 `BUILD SUCCESS`。

如果构建成功，您应该在当前目录中看到一个名为 target 的目录。目标目录应包含名为 com.yyit.mss.ch02.sample01-1.0.jar 的文件。 （其他文件将在 `target` 目录中，但您目前对它们不感兴趣。）然后从 chapter02/sample01/ 目录运行以下命令以启动订单处理微服务。在这里，我们使用了一个名为 spring-boot 的 Maven 插件：

[source,bash]
----
mvn spring-boot:run
----

如果微服务启动成功，您应该会在终端上看到一堆消息。在消息堆栈的底部，您应该会看到以下消息：

[source,text]
----
Started OrderApplication in <X> seconds
----

默认情况下，Spring Boot 在 HTTP 8080 端口启动微服务。如果您的本地机器上有其他服务在 8080 端口上运行，请确保停止它们；或者，您可以通过在 `chapter02/sample01/src/main/resources/application.properties` 文件中适当地更改 `server.port` 属性的值来更改订单处理微服务的默认端口。

=== 1.3. 访问订单处理微服务
默认情况下，Spring Boot 运行嵌入式 Apache Tomcat Web 服务器，该服务器监听端口 8080 上的 HTTP 请求。
在这里您将使用 curl 作为客户端应用程序访问您的微服务。
如果您在自定义端口上运行订单处理微服务，请确保将以下命令中的端口 (8080) 值替换为您使用的值。
要调用微服务，请打开命令行客户端并执行以下 curl 命令：

[source,shell script]
----
curl -v http://localhost:8080/orders \
-H 'Content-Type: application/json' \
--data-binary @- << EOF
{
  "items":[
    {
      "itemCode":"IT0001",
      "quantity":3
    },
    {
      "itemCode":"IT0004",
      "quantity":1
    }
  ],
  "shippingAddress":"福建省厦门市XX区XX街道XX小区XX栋XX室"
}
EOF
----

应该在终端上看到类似以下的响应数据：

[source,text]
----
{
  "orderId":"cd992a9f-6900-4625-b73a-0c526451dc81",
  "items":[{
    "itemCode":"IT0001","quantity":3},
    {"itemCode":"IT0004","quantity":1}],
  "shippingAddress":"福建省厦门市XX区XX街道XX小区XX栋XX室"
}
----

如果看到此消息，则您已成功开发、部署和测试了你的第一个微服务！

NOTE: 这个示例都使用 HTTP（而非 HTTPS）端点，这样您就不必设置正确的证书，并使您可以在需要时检查线路（网络）上传递的消息。在生产系统中，我们不建议对任何端点使用 HTTP。您应该仅通过 HTTPS 公开所有端点。在后面，我们将讨论如何使用 HTTPS 保护微服务。

当您执行上述命令时，curl 向位于服务器 localhost 上端口 8080（本地机器）上的 /orders 资源发起了 HTTP POST 请求。请求的内容（有效负载）表示为将要传送到特定地址的两件商品下的订单。 Spring Boot 服务器运行时（嵌入式 Tomcat）将此请求分派给 Order Processing 微服务的 `placeOrder` 方法（在 Java 代码中），后者响应消息。

=== 1.4 源代码目录中有什么？

让我们在 sample01 目录中导航并检查其内容。您应该会看到一个名为 `pom.xml` 的文件和一个名为 `src` 的目录。导航到 src/main/java/com/yyit/mss/ch02/sample01/service/ 目录。您将看到两个文件：`OrderApplication.java` 和 `OrderProcesingService.java`。

在深入研究这些文件的内容之前，让我们解释一下在此处尝试构建的内容。
微服务是网络可访问功能的集合。
在这种情况下，网络可访问意味着这些功能可以通过 Web 浏览器和移动应用程序等应用程序或 curl (https:// curl.haxx.se/) 能够通过 HTTP 进行通信。
通常，微服务中的函数作为对 REST 资源 (https://spring.io/guides/tutorials/rest/) 的操作公开。
通常，资源表示您打算检查或操作的对象或实体。
映射到 HTTP 时，资源通常由请求 URI 标识，verb 由 HTTP method(GET、POST、PUT、DELETE、OPTION、PATCH) 表示。


一个电子商务应用程序使用微服务来检索订单详细信息的场景。映射到微服务中该特定功能的 HTTP 请求模板类似于以下内容：
----
GET /orders/{orderid}
----

`GET` 是本例中使用的 HTTP 方法，因为您正在执行数据检索操作。 `/orders/{orderid}` 是托管相应微服务的服务器上的资源路径。
此路径可用于唯一标识订单资源。 `{orderid}` 是一个变量，需要在实际 HTTP 请求中替换为**适当**的值。
像 `GET /orders/d59dbd56-6e8b-4e06-906f-59990ce2e330` 这样会要求微服务检索 `ID` 为 `d59dbd56-6e8b-4e06-906f-59990ce2e330` 的订单的详细信息。


=== 1.5 理解微服务的源代码

让我们看一下代码示例，看看如何用 Java 开发一个方法并使用 Spring Boot 将其公开为 HTTP 资源。使用操作系统中的文件浏览器打开位于 sample01/src/main/java/com/yyit/mss/ch02/sample01/service 的目录，然后在文本编辑器中打开 `OrderProcessingService.java` 文件。如果您熟悉 Eclipse、NetBeans、IntelliJ IDEA 或任何类似的 Java 集成开发环境 (IDE)，您可以将示例作为 Maven 项目导入到 IDE。以下清单显示了 `OrderProcessingService.java` 文件的内容。

.清单 2.1 `OrderProcessingService.java` 文件的内容
```java
@RestController // 通知 Spring Boot 运行时将此类公开为微服务的 Rest 资源
@RequestMapping("/orders") // 指定服务所有资源所在的路径
public class OrderProcessingService {
    private Map<String, Order> orders = new HashMap<>();

    @PostMapping // 通知 Spring Boot 运行时将此方法公开为 POST HTTP 方法
    public ResponseEntity<Order> placeOrder(@RequestBody Order order) {
        System.out.println("接收到订单 "
                + order.getItems().size() + " 项");
        order.getItems().forEach((lineItem) ->
                System.out.println("订单项: " + lineItem.getItemCode() +
                        " 数量: " + lineItem.getQuantity()));
        String orderId = UUID.randomUUID().toString();
        order.setOrderId(orderId);
        orders.put(orderId, order);
        return new ResponseEntity<Order>(order, HttpStatus.CREATED);
    }
}
```

这段代码是一个简单的 Java 类，带有一个名为 `placeOrder` 的函数。您可能会注意到，我们使用 `@RestController` 注解装饰了该类，以通知 Spring Boot 运行时您有兴趣将此类公开为微服务。 `@RequestMapping` 注解指定了服务的所有资源所在的路径。我们还使用 `@PostMapping` 注解修饰了 `placeOrder` 函数，它通知 Spring Boot 运行时将此函数公开为 `/orders` 上下文中的 `POST` HTTP 方法（操作）。 `@RequestBody` 注解表示 HTTP 请求中的有效负载将分配给 `Order` 类型的对象。

同一目录中的另一个文件名为 `OrderApplication.java`。使用文本编辑器打开此文件并检查其内容，如下所示：

[source,java]
----
@SpringBootApplication
public class OrderApplication {
    public static void main(String args[]) {
        SpringApplication.run(OrderApplication.class, args);
    }
}
----

这个简单的 Java 类只有 `main` 函数。 `@SpringBootApplication` 注解通知 Spring Boot 运行时这个应用程序是一个 Spring Boot 应用程序。它还对 `OrderApplication` 类的同一个包中的 `Controller` 类（例如您之前看到的 `OrderProcessingService` 类）进行运行时检查。 `main` 函数是当您命令 JVM 运行特定 Java 程序时由 JVM 调用的函数。在 `main` 函数中，通过 `SpringApplication` 类的 `run` 实用程序函数启动 Spring Boot 应用程序，该类位于 Spring 框架中。

== 2. 设置 OAuth 2 服务器

现在已经启动并运行了你的第一个微服务，我们可以开始进入主要聚焦点：保护微服务。您将使用 OAuth 2 来保护您的边缘微服务。

当与 JWT 结合使用时，OAuth 2  可以成为一种高度可扩展的身份验证和授权机制，这对于保护微服务至关重要。

=== 2.1 与授权服务器的交互

在 OAuth 2 流程中，客户
端应用程序、最终用户和资源服务器都在不同阶段直接与授权服务器交互（见图 2）。
在从授权服务器请求令牌之前，客户端应用程序必须向它注册自己。

.2 OAuth 2 流程中的参与者：在典型的访问委托流程中，客户端（代表最终用户）使用授权服务器提供的令牌访问托管在资源服务器上的资源
[caption="图 . "]
image::doc/2.2.dio.png[]

授权服务器仅为它知道的客户端应用程序颁发令牌。一些授权服务器支持动态客户端注册协议 ( https://tools.ietf.org/html/rfc7591 )，它允许客户端即时或按需在授权服务器上注册自己（见图 3）。

.3 客户端应用程序向授权服务器请求访问令牌。授权服务器只向已知的客户端应用程序颁发令牌。客户端应用程序必须首先在授权服务器上注册。
[caption="图 . "]
image::doc/2.3.dio.png[]

Order Processing 微服务在这里扮演了**资源服务器**的角色，它会从客户端接收授权服务器发出的令牌，通常作为 HTTP 请求头或客户端发出 HTTP 请求时的查询参数（参见第 1 步）图 4)。_建议客户端通过 HTTPS 与微服务通信_，并在 HTTP header 而不是查询参数中发送令牌。因为查询参数是在 URL 中发送的，所以这些参数可以记录在服务器日志中。因此，任何有权访问日志的人都可以看到此信息。

使用 TLS 来保护 OAuth 2 流中所有实体之间的通信（或换句话说，使用 HTTPS）非常重要。
授权服务器为访问微服务（或资源）而颁发的令牌（访问令牌）必须像密码一样受到保护。
我们不会通过纯 HTTP 发送密码，而是始终使用 HTTPS。
因此，我们在通过网络发送访问令牌时遵循相同的过程。

.4 客户端应用程序在 HTTP 授权请求头中传递 OAuth 访问令牌以从资源服务器访问资源。
[caption="图 . "]
image::doc/2.4.dio.png[]

收到访问令牌后，订单处理微服务应在授予对其资源的访问权限之前根据授权服务器对其进行验证。
OAuth 2 授权服务器通常支持 OAuth 2 令牌自省配置文件 (https://tools.ietf.org/html/rfc7662) 或资源服务器的类似替代方案，
以检查访问令牌的有效性（见图 5）。
如果访问令牌是自包含的 JWT，资源服务器可以自行验证它，而无需与授权服务器交谈。我们将在后面详细讨论自包含的 JWT。

.6 订单处理微服务（资源服务器）通过与授权服务器对话来内省访问令牌。
[caption="图 . "]
image::doc/2.5.dio.png[]

=== 2.2 运行 OAuth 2 授权服务器

许多生产级 OAuth 2.0 授权服务器都在那里，既有专有的，也有开源的。
然而，在本章中，我们使用一个能够发布访问令牌的简单授权服务器。
它是使用 Spring Boot 构建的。在之前克隆的 Git 源码库中，您应该会在目录 Chapter02 下找到一个名为 sample02 的目录。
您将在那里找到简单 OAuth 2 授权服务器的源代码。首先，编译并运行它；然后查看代码以了解它的作用。

要编译，使用命令行客户端导航到 chapter02/sample02 目录。从该目录中，执行以下 Maven 命令以编译和构建可运行 artifact：

----
mvn clean install
----

如果您的构建成功，您将看到消息 BUILD SUCCESS。您应该在名为 target 的目录中找到名为 com.yyit.mss.ch02.sample02-1.0.jar 的文件。从chapter02/sample02 目录中使用命令行客户端执行以下命令，以运行OAuth 2.0 授权服务器：

----
mvn spring-boot:run
----

如果成功运行服务器，应该看到以下消息：
----
Started OAuthServerApplication in <X> seconds
----

此消息表明您已成功启动授权服务器。默认情况下，OAuth 2.0 授权服务器在 HTTP 端口 8085 上运行。如果您的本地机器上有任何其他服务在 8085 端口上运行，请确保停止它们；或者，您可以通过在 chapter02/sample02/src/main/resources/application.properties 文件中适当地更改 server.port 属性的值来更改授权服务器的默认端口。

=== 2.3 从 OAuth 2 授权服务器获取访问令牌

要从授权服务器获取访问令牌，请使用 HTTP 客户端向服务器发出 HTTP 请求。在现实世界中，访问微服务的客户端应用程序会发出此请求。为此，您将使用 curl 作为 HTTP 客户端。要从授权服务器（在端口 8085 上运行）请求访问令牌，请使用命令行客户端运行以下命令：

[source,bash]
----
curl -H "Content-Type: application/x-www-form-urlencoded" \
-d 'grant_type=client_credentials&client_id=yyit&client_secret=123456' \
-X POST http://localhost:8085/oauth2/token
----

如果您的请求成功，您应该会看到类似于以下内容的响应：

[source,json]
----
{
  "access_token":"eyJraWQiOiJhOTQ5ODkyNC1kODE1LTRlZmItODlmYS1lYmFkMmFkOTU4OGMiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ5eWl0IiwiYXVkIjoieXlpdCIsIm5iZiI6MTY1MTExNzE2MCwic2NvcGUiOlsib3BlbmlkIiwib3JkZXJzIl0sImlzcyI6Imh0dHA6XC9cL2xvY2FsaG9zdDo5MDAwIiwiZXhwIjoxNjUxMTE3NDYwLCJpYXQiOjE2NTExMTcxNjB9.SboppQgJ57rKCiq2sIivOeOKxNJoYjEZ-YXFjeLAE1x80cPLBAwf106YuUsZJNyxW_3uEn0K7JNIT7DWg3mVdhIHe5XOAD7W6nRR3DP_e3WXlXwugaNxDIInXBCFqTPleVldeSXEjMMpSGrsDnaIClAV1D9c0vrfZCtrUT0CvUO_tgMWtpQyCXGHLeeDsDYtasxXvgsocnozfoNpQyxvBdARtsqZEmBIErDPP-gr7FN_KETqiUfQ_CZMjVYV-992SNW-l7kOxdI03LhLygQ6CBiQWkCehQu1YMGgroiMVS6x1-yeT1A2LpClnnr2HsUbZAa9BDEMUzLqjDVZXCopqQ",
  "scope":"openid orders",
  "token_type":"Bearer",
  "expires_in":300
}
----

=== 2.4 理解访问令牌响应

以下列表提供了有关来自授权服务器的上述 JSON 响应的详细信息。

- _access_token_ — 授权服务器向客户端应用程序颁发的令牌值（在本例中为 curl）。

- _token_type_ — 令牌类型（当我们在附录 A 中讨论 OAuth 2.0 时将详细介绍此主题）。我们今天看到的大多数 OAuth 部署都使用不记名令牌。

- _expires_in_ — 令牌的有效期，以秒为单位。在此期间之后，令牌将被视为无效（过期）。

- _scope_ — 允许令牌在资源服务器（微服务）上执行的操作。

== 3 使用 OAuth 2 保护微服务

