= 微服务安全第三课(使用 API 网关保护北/南流量)
:author: yyit
:stem: latexmath
:icons: font
:source-highlighter: coderay
:sectlinks:
:sectnumlevels: 4
:toc: left
:toc-title: 目录
:toclevels: 3

在第 2 课中，我们讨论了如何使用 OAuth 2 在边缘保护微服务。第 2 课的重点是通过简单的部署开始工作。
第 2 课中的示例远未准备好生产。每个微服务都必须连接到 OAuth 2 授权服务器以进行令牌验证，并决定它想要信任哪个 OAuth 2 授权服务器。
当您拥有数百个微服务并且微服务开发人员承担过多责任时，这不是一个可扩展的模型。

在理想的情况下，微服务开发人员应该只关心微服务的业务功能，其余的应该由专门的组件处理，麻烦更少。
API 网关和服务网格是帮助我们实现这一理想的两种架构模式。在本课中，我们将讨论 API 网关模式，并在后面讨论服务网格模式。
API 网关模式主要是关于边缘安全，而服务网格模式处理服务到服务的安全。
或者，换句话说，_API Gateway 处理北/南流量，而 Service Mesh 处理东/西流量_。
我们将实现 API 网关模式的软件称为 API 网关，而将实现服务网格模式的软件称为服务网格。

边缘安全是关于在 API 网关的部署入口点保护一组资源（例如，一组微服务）。
API 网关是我们微服务部署的唯一入口点，用于处理来自外部的请求。在服务网格模式中，架构更加分散。
每个微服务都有自己的策略执行点，离服务更近——大多数情况下它是一个 proxy，运行在每个微服务旁边。
API 网关是整个微服务部署的集中策略执行点，而在服务网格中，与每个微服务一起运行的代理在服务级别提供另一个级别的策略执行。
在后续课程，我们将讨论如何利用本课中讨论的 API 网关模式以及服务网格模式来构建端到端的安全解决方案。


== 1 微服务部署中对 API 网关的需求

在微服务部署中拥有 API 网关很重要。 API 网关是我们架构中的重要基础设施，因为它起着关键作用，可以帮助我们清楚地将功能性需求与非功能性需求区分开来。
我们将扩展第 2 课的用例（一家零售店），查看其中的一些问题，并解释如何使用 API 网关模式解决这些问题。

在典型的微服务部署中，微服务不会直接暴露给客户端应用程序。
在大多数情况下，微服务位于一组通过 API 网关向外界公开的 API 之后。
API 网关是微服务部署的入口点，它会筛选所有传入消息以确保安全性和其他 QoS 功能。

图 1 描绘了一个典型微服务部署，其中所有微服务都以 Spring Cloud Gateway API 网关为前端。
Spring Cloud Gateway 提供动态路由、监控、弹性、安全性等。它充当服务器基础设施的前门，处理来自世界各地用户的流量。
在图 1 中，Spring Cloud Gateway 用于通过 API 公开订单处理微服务。
我们不会从 API 网关公开库存和物流微服务，因为外部应用程序不需要访问这些微服务。

.1 带有 API 网关的典型微服务部署。 API 网关筛选所有传入消息的安全性和其他服务质量特性。
[caption="图 . "]
image::doc/3.1.dio.png[]

=== 1.1 安全与微服务解耦

微服务最佳实践的一个关键方面是单一职责原则。
这个在编程中常用的原则表明，每个模块、类或函数都应该负责软件功能的一个部分。
在这个原则下，每个微服务应该只执行一个特定的功能。

在第 2 课的示例中，安全订单处理微服务的实现方式是，除了处理订单的核心业务功能外，它还必须与授权服务器通信并验证从客户端应用程序获得的访问令牌。
如图 2 所示，订单处理微服务不得不担负这里列出的多个任务：

- 从传入的请求中提取安全请求头（token）
- 事先知道授权服务器的位置，它必须与之交互以验证安全 token
- 了解与授权服务器通信的协议和消息格式，以验证安全 token
- 优雅地处理 token 验证流程中的错误，因为微服务直接暴露给客户端应用程序
- 执行与处理订单相关的业务逻辑

.2 客户端应用程序、微服务和授权服务器之间的交互。订单处理微服务处理的功能比理想情况下要多。
[caption="图 . "]
image::doc/3.2.dio.png[]

执行所有这些步骤会成为一个问题，因为微服务通过执行比预期更多的操作而失去了它的原子特性。
微服务最好只执行前面列表中的第五项任务，这是处理我们设计微服务所针对的业务逻辑的任务。
安全和业务逻辑的耦合给微服务带来了不必要的复杂性和维护开销。
例如，更改安全协议将需要更改微服务代码，而扩展微服务将导致与授权服务器的更多连接。

==== 安全协议的变化需要微服务的变化

如果决定从 OAuth 2.0 转移到微服务上强制执行的安全协议，您必须在微服务中进行更改，即使它可能没有任何与其业务逻辑相关的更改。
此外，如果您发现当前安全实现中的错误，则需要修补微服务代码以修复它。
这种不必要的开销会损害设计、开发和部署微服务的敏捷性。

==== 扩展微服务导致与授权服务器的更多连接

需要运行更多的微服务实例来满足不断增长的需求。
想想双十一购物节，人们在您的零售网店下的订单比平时多，这需要您扩展微服务以满足需求。
由于每个微服务都与授权服务器对话以进行令牌验证，因此扩展微服务也会增加与授权服务器的连接数。

50 个用户使用单个微服务实例和 50 个用户使用 10 个微服务实例之间存在差异。
为了迎合这 50 个用户，单个微服务可能会维护一个大约 5 个的连接池来与授权服务器通信。
当微服务的每个实例维护 5 个连接池以连接到授权服务器时，10 个微服务实例最终会在授权服务器上创建 50 个连接，而不是 5 个。
图 3 说明了扩展微服务以满足增加的需求。

.3 微服务扩容时对授权服务器的影响，导致授权服务器负载增加
[caption="图 . "]
image::doc/3.3.dio.png[]

API 网关有助于将安全性与微服务分离。它拦截所有进入微服务的请求，与相应的授权进行对话，并仅将合法请求分派给上游微服务。
否则，它会向客户端应用程序返回一条错误消息。

=== 1.2 微服务部署固有的复杂性使其更难消费

一个微服务部署通常由许多微服务和这些微服务之间的许多交互组成（图 4）

.4 微服务部署的架构图，展示了服务和它们之间的连接
[caption="图 . "]
image::doc/3.4.dio.png[]

使用微服务来构建自己的功能的应用程序必须能够与多个微服务进行通信。
想象一个拥有多个团队的组织，其中每个团队都有职责开发图 4 中所示的微服务之一。
每个团队的开发人员可以使用自己的微服务技术栈以及自己的标准和实践。
这些微服务的不一致性让消费应用程序的开发人员很难，他们需要学习如何处理许多不一致的接口。

API 网关解决方案通常作为 API 管理软件的一部分提供，可以为向消费应用程序公开的接口带来一致性。
微服务本身可能不一致，因为它们现在对外界隐藏，而 API 网关可以处理与微服务交互的复杂性。

=== 1.3 微服务的原始性并不适合对外暴露

微服务可以根据需要进行细化。假设您的 Products 微服务中有两个操作：一个用于检索您的产品目录，另一个用于向目录中添加产品项。
从 REST 的角度来看，检索产品的操作将在 `/products` 资源上建模为 `GET`，而添加产品的操作将在 `/products` 资源上建模为 `POST`。
`GET /products` 获取产品列表（读取操作）。 `POST /products` 将一个新产品添加到产品列表中（写操作）。

在实践中，您可以预期读取操作的请求比写入操作的请求多，因为在零售网站上，人们浏览产品的频率比添加到目录中的项目要频繁得多。
因此，您可以决定在两个不同的微服务（甚至可能是不同的技术堆栈）上实现 `GET` 和 `POST` 操作，以便它们可以独立扩展微服务。
该解决方案提高了健壮性，因为一个微服务的故障不会影响另一个微服务执行的操作。
然而，从消费的角度来看，消费应用程序必须与两个端点（两个 API）对话以进行添加和检索操作是很奇怪的。
强烈的 REST 拥护者可能会争辩说，将这两个操作放在同一个 API（同一个端点）上更有意义。

API 网关架构模式是解决此问题的理想解决方案。它为消费应用程序提供了一个具有两种资源（GET 和 POST）的 API。
每个资源都可以由自己的微服务支持，提供微服务层所需的可扩展性和健壮性（见图 5）。

.5 多个微服务在网关上作为单个 API 公开。客户端应用程序只需要关心一个端点。
[caption="图 . "]
image::doc/3.5.dio.png[]

== 2 边缘安全

我们将了解为什么 OAuth 2.0 是保护边缘微服务的最合适协议。在典型的微服务部署中，我们不会直接向客户端应用程序公开微服务。
API 网关是微服务部署的入口点，它有选择性地将微服务作为 API 公开给客户端应用程序。

在大多数情况下，这些 API 网关使用 OAuth 2.0 作为安全协议来保护它们在边缘公开的 API。

=== 2.1 了解微服务的消费者格局

正如前面所讨论的，组织和企业采用微服务的主要原因是它们为开发服务提供的敏捷性。
组织希望尽可能敏捷地开发和部署服务。这一步伐是由消费类应用需求的增长推动的。
今天，人们在大多数日常活动中使用移动应用程序，例如订购比萨饼、杂货店购物、网络、社交互动和银行业务。这些移动应用程序使用来自不同提供商的服务。

在组织中，其内部和外部（例如第三方）应用程序都可以使用微服务。
外部应用程序可以是移动应用程序、公共互联网上的 Web 应用程序、运行在设备或汽车上的应用程序等。
要使这些类型的应用程序正常工作，需要通过 HTTPS 在公共互联网上公开您的微服务。
因此，不能仅仅依靠网络级安全策略来阻止对这些微服务的访问。
因此，可能总是不得不依赖上层安全来控制访问。
这里的上层安全是指 TCP/IP 协议栈（www.w3.org/People/Frystyk/thesis/TcpIp.html）中的层。
您需要依赖应用于网络层之上的安全，例如传输层或应用层协议，包括 TLS 和 HTTPS。

在组织的计算基础设施内运行的应用程序可能同时使用面向内部和面向外部的微服务。
面向内部的微服务也可能被其他面向外部或面向内部的微服务使用。
如图 6 所示，在零售网店示例中，用于浏览产品目录的微服务（产品微服务）和用于接单的微服务（订单处理微服务）是面向外部的微服务，它们需要在组织的安全边界之外运行的应用程序。
但是用于更新库存的微服务——库存微服务——不需要暴露在组织的安全边界之外，因为只有在下订单（通过订单处理微服务）或添加库存时才会更新库存通过内部应用程序进行盘点。


.6 内部微服务、外部微服务和混合微服务，每个微服务都相互通信以实现其功能
[caption="图 . "]
image::doc/3.6.dio.png[]

=== 2.2 委托访问

人类用户不太可能（但并非不可能）直接与 API 交互。这是访问委派很重要的地方，并且在保护 API 方面发挥着关键作用。

.7
[caption="图 . "]
image::doc/3.7.dio.png[]

应该只允许用户（资源所有者）对他们有权执行的微服务执行操作。用户从微服务中检索或通过微服务更新的数据应该只是他们有权接收或更新的数据。尽管针对用户检查此级别的权限，但代表用户访问微服务的实体是用户使用的客户端应用程序。换句话说，用户有权在微服务上执行的操作由客户端应用程序执行。实际上，用户将其访问权限委托给访问微服务资源的应用程序。因此，应用程序有责任适当地处理委派的权利。

因此，应用程序的可信度很重要。
特别是当第三方应用程序被用于访问您的微服务上的资源时，拥有一种允许你控制应用程序可以对你的资源执行哪些操作的机制变得很重要。
控制对客户端应用程序的访问授权是决定保护微服务的机制的重要因素。

=== 2.3 为什么不使用 Basic 身份验证来保护 API？

Basic 身份验证允许具有有效用户名和密码的用户（或系统）通过 API 访问微服务。
事实上，Basic 身份验证是很久以前在 RFC 1945 中随 HTTP/1.0 引入的标准安全协议。
它允许您在 HTTP 授权 header 中传递 base64 编码的用户名和密码，以及对 API 的请求。

- *用户名和密码是静态的、长期存在的凭据*。如果用户向应用程序提供用户名和密码，则应用程序需要保留此信息以供该特定用户会话访问微服务。需要保留此信息的时间可能与应用程序决定的时间一样长。我们都不喜欢必须一次又一次地对应用程序进行身份验证才能执行操作。因此，如果使用基本身份验证，应用程序必须长时间保留此信息。这些信息保留的时间越长，被入侵的可能性就越大。而且由于这些凭据几乎从不改变，因此泄露这些信息可能会产生严重的后果。

- *对应用程序的功能没有限制*。在应用程序获得用户的用户名和密码之后，它就可以做用户通过微服务可以做的任何事情。除了访问微服务之外，应用程序还可以使用这些凭证做任何事情，甚至在其他系统上也是如此。

=== 2.4 为什么不使用双向 TLS 来保护 API？

相互传输层安全(Mutual Transport Layer Security)是一种机制，通过这种机制，客户端应用程序验证服务器，服务器通过交换各自的证书并证明每个应用程序都拥有相应的私钥来验证客户端应用程序。目前，可以将mTLS看作一种使用证书在客户机应用程序和服务器之间构建双向信任的技术。

mTLS 通过为其证书提供一个生命周期来解决 Basic 身份验证的一个问题。mTLS 中使用的证书是有时间限制的，当一个证书过期时，就不再认为它是有效的。因此，即使证书和相应的私钥被泄露，其漏洞也受到其生存期的限制。然而，在某些情况下，证书的生存期长达数年，因此 mTLS 相对于 Basic 身份验证等协议的价值是有限的。同样，与 Basic 身份验证(通过网络发送密码)不同，当您使用 mTLS 时，相应的私钥不会离开它的所有者——或者从不通过网络传递。这是 mTLS 相对于 Basic 身份验证的主要优势。

然而，就像在 Basic 身份验证中一样，mTLS 不能满足微服务部署中的访问委托需求。mTLS 没有提供一种机制来表示使用相应应用程序的最终用户。可以使用 mTLS 对与微服务通信的客户端应用程序进行身份验证，但它不代表最终用户。如果想通过 mTLS 传递最终用户信息，需要遵循自己的自定义技术，例如将用户名作为自定义 HTTP header 发送，这是不推荐的。因此，mTLS 主要用于保护客户端应用程序和微服务之间的通信，或微服务之间的通信。换句话说，mTLS 主要用于确保系统之间的通信安全。

=== 2.5 为什么是 OAuth 2？

要了解为什么 OAuth 2.0 是在边缘保护微服务的最佳安全协议，首先需要了解你的受众。
你需要弄清楚谁想要访问你的资源、出于什么目的以及访问时间。
你必须通过微服务的特征和需求正确了解微服务的受众：

- Who — 确保只有允许的主体才能访问您的资源

- What purpose — 确保被允许的主体只能对您的资源执行他们被允许执行的操作

- How long — 确保仅在所需时间段内授予访问权限

微服务的受众是一个代表自身、人类用户或其他系统运行的系统。微服务的所有者应该能够将对其拥有（或有权访问）的微服务的访问权限委托给系统。委托是保护微服务的关键要求——在所有安全协议中，专为访问委托而设计的 OAuth 2.0 最适合在边缘保护微服务。


== 3 使用 Spring Cloud Gateway 设置 API 网关

本课的前面我们说明了 API 网关为何是微服务部署的重要组件。接下来将为订单处理微服务设置一个 API 网关，使用 Spring 家族的 Spring Cloud Gateway。

=== 3.1 编译运行订单处理微服务

在 lesson03 目录中看到名为 sample01 的目录。这与 lesson03 中使用的示例相同。
从命令行客户端应用程序导航到 lesson03/sample01 目录，并执行以下命令以构建订单处理微服务的源代码：

----
mvn clean install
----

如果构建成功，您应该会在终端上看到一条消息，说 BUILD SUCCESS。如果您看到此消息，则可以通过从同一位置执行以下命令来启动微服务：

----
mvn spring-boot:run
----

如果服务成功启动，您应该在终端上看到一条日志语句，上面写着 Started OrderApplication in <X> seconds。
如果您看到此消息，则您的订单处理微服务已启动并正在运行。
现在使用 curl 向它发送请求，以确保它正确响应：

```bash
curl -v http://localhost:8080/orders \
-H 'Content-Type: application/json' \
--data-binary @- << EOF
{
  "items":[
    {
      "itemCode":"IT0001",
      "quantity":3
    },
    {
      "itemCode":"IT0004",
      "quantity":1
    }
  ],
  "shippingAddress":"福建省厦门市XX区XX街道XX小区XX栋XX室"
}
EOF
```

成功执行此请求后，你应该会看到类似的响应消息：
```json
{
  "orderId":"cd992a9f-6900-4625-b73a-0c526451dc81",
  "items":[{
    "itemCode":"IT0001","quantity":3},
    {"itemCode":"IT0004","quantity":1}],
  "shippingAddress":"福建省厦门市XX区XX街道XX小区XX栋XX室"
}
```

这个请求让 curl（一个客户端应用程序）直接访问你的订单处理微服务，
如图 8 所示。您的客户端应用程序向订单处理微服务发送了下订单请求。
正如您在响应消息中看到的，特定订单的 ID 是 `cd992a9f-6900-4625-b73a-0c526451dc81`。稍后，当你尝试使用 `GET / orders/{id}` 资源检索相同的订单时，你应该能够获得所下订单的详细信息。

.8 客户端应用程序直接向订单处理微服务发送请求并获得带有订单 ID 的响应。
[caption="图 . "]
image::doc/3.8.dio.png[]

=== 3.2 编译运行 API 网关

下一步是编译和运行 API 网关作为订单处理微服务的代理。导航到命令行客户端中的 lesson03/sample02 目录，然后执行以下命令：

```
mvn clean install
```

您应该会看到 BUILD SUCCESS 消息。接下来，通过在同一目录中执行以下命令来运行 API 网关代理：

----
mvn spring-boot:run
----

您应该会看到 server-start-successful 消息。现在尝试通过 API 网关代理访问您的订单处理微服务。
为此，您将尝试检索所下订单的详细信息。从您的终端应用程序执行以下命令：

----
curl \
http://localhost:9090/api/orders/cd992a9f-6900-4625-b73a-0c526451dc81
----

此响应应包含之前创建的订单的详细信息。请注意此请求中的几个要点：

- 这次发送请求的端口 (9090) 与订单处理微服务的端口 (8080) 不同，因为您将请求发送到 API 网关代理而不是直接订单处理微服务。
- 请求 URL 现在以 /api/orders 开头，这是在 API 网关中配置的基本路径，用于将请求路由到订单处理微服务。要查看路由是如何配置的，请使用文本编辑器打开位于 sample02/src/main/resources 目录中的 application.yml 文件。您在那里找到 /api/orders 上收到的请求路由到在 http://localhost:8080 上运行的服务器：

图 9 说明了 API 网关如何通过将它从客户端应用程序获取的请求分派到订单处理微服务来进行路由。


.9 所有对微服务的请求都需要通过网关。
[caption="图 . "]
image::doc/3.9.dio.png[]

=== 3.3 在 Spring Cloud Gateway 网关上实现基于 OAuth 2 的安全性

现在已经通过 API 网关成功代理了订单处理微服务，下一步是在 API 网关上实现安全性，只有经过身份验证的客户端才能访问订单处理微服务。
首先，需要一个 OAuth 2 授权服务器，它能够向客户端应用程序颁发访问令牌。
在典型的生产部署架构中，授权服务器部署在组织的网络内部，只有所需的端点对外公开。通常，API 网关是唯一允许从外部访问的组件；
其他一切都在组织的局域网内受到限制。
在示例中，授权服务器的 `/oauth2/token` 端点通过 API 网关公开，以便客户端可以从授权服务器获取访问令牌。
图 10 说明了这种部署架构。

.10 防火墙保证只有通过 API 网关才能访问授权服务器和微服务。
[caption="图 . "]
image::doc/3.10.dio.png[]

要构建授权服务器，请从命令行客户端导航到 lesson03/sample03 目录，然后执行以下命令：

----
mvn clean install
----

授权服务器搭建完成后，可以使用以下命令启动：

----
mvn spring-boot:run
----

当授权服务器成功启动后，您可以通过 Spring Cloud Gateway 网关向其请求令牌。
但是，我们没有在 Spring Cloud Gateway 网关上强制执行 OAuth 2.0 安全筛选，从 3.2 节中的 sample02 开始。
因此，您需要停止它并从 sample04 构建并运行一个新的 Spring Cloud Gateway 网关，我们在其中实现了 OAuth 2 安全筛选。

在构建 sample04 之前，首先查看 sample04/src/main/resources/application.yml 文件中的以下属性。
此属性指向授权服务器的令牌验证端点。

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8085
```

要构建新的 API 网关，请打开一个新的终端窗口并导航到 lesson03/sample04 目录，然后执行以下命令：

----
mvn clean install
----

网关构建完成后，可以使用以下命令启动它：

----
mvn spring-boot:run
----

一旦网关在端口 9090 上成功启动，在新的终端窗口上执行以下命令，通过 API 网关从授权服务器获取访问令牌。
这里我们使用 OAuth 2.0 client_credentials 授权类型，`orderprocessingapp` 作为 Client ID，`orderprocessingsecret` 作为 Client Secret：

```bash
curl -u orderprocessingapp:orderprocessingsecret \
-H "Content-Type: application/x-www-form-urlencoded" \
-d "grant_type=client_credentials" \
http://localhost:9090/api/oauth2/token
```

应该在如下所示的响应中收到访问令牌：

```json
{
  "access_token":"eyJraWQiOiIxMmJlZDVlMi1hNzM2LTQ2ZjUtOWJlYS02NzRlYzQxMDA2ODQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJvcmRlcnByb2Nlc3NpbmdhcHAiLCJhdWQiOiJvcmRlcnByb2Nlc3NpbmdhcHAiLCJuYmYiOjE2NTEyMjE1OTksInNjb3BlIjpbInJlYWQiLCJvcGVuaWQiLCJ3cml0ZSJdLCJpc3MiOiJodHRwOlwvXC9sb2NhbGhvc3Q6ODA4NSIsImV4cCI6MTY1MTIyMTg5OSwiaWF0IjoxNjUxMjIxNTk5fQ.F5uO0IZpccBCXT2UDX9tkFszTh1bgK32DMunmJg4pWbXuF2kyomjRSf6e40bdgXOk7A60WHm7Vy7CGfSBP4it4wmuCGqfC6hZsfTzqizv012ilkpH1FEz8-C6fEZR29kl18A6jJGxH9ai6u6Ntb6Xo4AJOCI3oAL-X0H2W96QPOy-AvzXpTOl9SJSRuLOgxFnTotkq-UiaCLT97Si-mY_FZXOBxPjgU6VHZGyBO40po0Pjt-vtEujEY9_7c8kyO8R75V5JiAAYXI3wEl7Jj-1IZtX5C3gdQkRQ0exPIfsNCQTT6gAL_z3XKmPD91f_950wygwpT66jDUxXqHF4LGLQ",
  "scope":"read openid write",
  "token_type":"Bearer",
  "expires_in":299
}
```

客户端应用程序从授权服务器的令牌端点获取访问令牌后，客户端应用程序将使用此令牌通过 API 网关访问订单处理微服务。
通过 API 网关公开订单处理微服务的目的是使网关强制执行所有与安全相关的策略，而订单处理微服务只关注它执行的业务逻辑。
这种情况符合微服务的原则，即微服务应该专注于做一件事。
仅当请求客户端携带有效的 OAuth 2 访问令牌时，API 网关才允许对订单处理微服务的请求。

现在，让我们像以前一样尝试使用以下命令通过 API 网关访问订单处理微服务（没有有效的访问令牌）：

```bash
curl -v \
http://localhost:9090/api/orders/7c3fb57b-3198-4cf3-9911-6dd157b93333
```

此命令现在应该为您提供一条身份验证错误消息，如下所示。
此错误消息确认 API 网关在强制执行 OAuth 2.0 安全筛选的情况下不允许任何请求在没有有效令牌的情况下通过它：

```
< HTTP/1.1 401
< Transfer-Encoding: chunked
<
{"error": true, "reason":"Authentication Failed"}
```

网关不再授予对资源服务器上资源的开放访问权限。它要求进行身份验证。
因此，我们需要使用有效的令牌通过 API 网关访问订单处理微服务。让我们使用刚刚通过 /token 端点获取的访问令牌重试访问同一个订单处理微服务。
为此，您可以使用以下命令。
确保具有第 3.1 中的正确订单 ID，并将以下命令中的 `7c3fb57b-3198-4cf3-9911-6dd157b93333` 替换为它：

```bash
curl \
http://localhost:9090/api/orders/7c3fb57b-3198-4cf3-9911-6dd157b93333 \
-H "Authorization: Bearer eyJraWQiOiIxMmJlZDVlMi1hNzM2LTQ2ZjUtOWJlYS02NzRlYzQxMDA2ODQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJvcmRlcnByb2Nlc3NpbmdhcHAiLCJhdWQiOiJvcmRlcnByb2Nlc3NpbmdhcHAiLCJuYmYiOjE2NTEyMjE1OTksInNjb3BlIjpbInJlYWQiLCJvcGVuaWQiLCJ3cml0ZSJdLCJpc3MiOiJodHRwOlwvXC9sb2NhbGhvc3Q6ODA4NSIsImV4cCI6MTY1MTIyMTg5OSwiaWF0IjoxNjUxMjIxNTk5fQ.F5uO0IZpccBCXT2UDX9tkFszTh1bgK32DMunmJg4pWbXuF2kyomjRSf6e40bdgXOk7A60WHm7Vy7CGfSBP4it4wmuCGqfC6hZsfTzqizv012ilkpH1FEz8-C6fEZR29kl18A6jJGxH9ai6u6Ntb6Xo4AJOCI3oAL-X0H2W96QPOy-AvzXpTOl9SJSRuLOgxFnTotkq-UiaCLT97Si-mY_FZXOBxPjgU6VHZGyBO40po0Pjt-vtEujEY9_7c8kyO8R75V5JiAAYXI3wEl7Jj-1IZtX5C3gdQkRQ0exPIfsNCQTT6gAL_z3XKmPD91f_950wygwpT66jDUxXqHF4LGLQ"
```



在前面的示例中，API 网关与授权服务器（令牌颁发者）通信以验证它从 `curl` 客户端应用程序获得的令牌。在第 2 课中了解到的，此过程称为令牌自省 (https://tools.ietf.org/html/rfc7662) 。从客户端到 Order Processing 微服务的请求流程如图 11 所示。

.11 从客户端应用获取令牌到访问微服务的消息交换
[caption="图 . "]
image::doc/3.11.dio.png[]

如您所见，客户端应用程序将 OAuth 2.0 访问令牌作为标头发送到暴露订单处理微服务的路径 (/api/orders) 上的 API 网关。
网关从 header 中提取令牌并通过授权服务器对其进行内省。
授权服务器以有效或无效的状态消息响应；
如果状态有效，网关允许将请求传递给订单处理微服务。

